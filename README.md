# Genetic Algorithm for the Qubit Mapping Problem

## What is the Qubit Mapping Problem?
When running a program on a quantum computer, it is required that logical qubits of the program be mapped appropriately to the physical qubits in the system. This is important because the manipulation of these qubits is fundamental to the operation of the program (Hadamard, Pauli-X, S, etc. gates), and the location of these qubits in relation to each other for perfoming a gate operation matters. Each quantum computer is built differently as well, each with its own physical architecture. The way in which the logical qubits can be moved around within the architecture is by inserting SWAP gates into the program, so that the qubits can be operated on the moment they are needed in the program. This is done by the quantum computing compiler and is a costly process. Inserting more gates into the circuit will result in a generally higher probability of error, decreasing robustness of the program. So, an optimization problem in the field of QC is finding the most optimal method of minimizing the number of inserted SWAPs by the compiler. One of the best known solutions, SABRE, is directly compared to with my own implementation.

## My Design
The primary algorithm behind my design is the genetic algorithm (GA). We know that the lookahead routing method can perform quite well, but one if its major drawbacks is its approach to the initial mapping (being nonexistent), which can have a large impact on performance when adding SWAPs to make a circuit CNOT-compatible with an architecture. I decided to wrap the lookahead routing method in a genetic algorithm to find the optimal initial mapping configuration. This not only made an improvement to the lookahead method in general, but also beat out SABRE in most cases that were tested, sometimes at the expense of runtime.

## How the GA works
My GA works by initializing a population size of 40 individuals. The characteristics of the individual is completely dynamic, depending on the width of the circuit and the coupling map used. The characteristics of each individual can be simply thought of as an initial layout, where its list of virtual to physical qubit mapping defines its "genes". Each population is evaluated by simulating the corresponding quantum circuit, from which a fitness value is obtained for each individual to distinguish who will survive to produce offspring. In this case, the fitness value is simply the number of SWAPs added, in which the best fit individuals will have the lowest fitness value. 50% of the population is then killed off, from which the top 50% of individuals are selected for cross-breeding. This is where the "chromosomes" that make up a pair of individuals are spliced, mixed, then recombined to produce new offspring. Each child is made up of 50% from each parent where the combination of chromosomes inherited maintain some order from their respective parents. There is also a ~2% probability of random mutation of the genes, which ensures our optimization does not prematurely converge.


**Note**: To save on computational time, many initial mappings for the lookahead method were found to have a near-optimal solution when simply using the "basic" routing method for determining the fitness of the population. This "basic" method is quite inefficient by itself, but much faster than the lookahead method in most cases. Once this initial mapping was found, then the lookahead method could be sometimes be applied to find an even better reduction in SWAP's given the same layout. Furthermore, many smaller circuits (BV-10, etc.) performed better than SABRE when ONLY using the "basic" routing method with this genetic algorithm, sometimes converging within seconds. (The results of the purely "basic" approach is in the file `opt1_results.basic`)

